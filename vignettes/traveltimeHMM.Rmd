---
title: "An introduction to traveltimeHMM : Making reliable travel time predictions for routes on a road networks"
author: "Mohamad Elmasri, Aurélie Labbe, Denis Larocque, Laurent Charlin and Éric Germain"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to traveltimeHMM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Travel time prediction has many uses for individuals and organizations wishing to estimate the time it takes to complete a given route, but also to choose the best route available for a given trip.  Predictions are likely to be more useful if they include some reliability measure for the expected travel time.  The `traveltimeHMM` package leverages data on vehicle speeds on a set of road links at various points in time to predict the probability distribution of travel time on a given sequence of links, or trip.  The availability of full probability distributions allows better risk management during trip planning.  The package implements a version of the TRIP method proposed in Woodard et al. (2017).

## Example data set: `tripset`

We will use the example input data set `tripset` to explore the functionalities offered by `traveltimeHMM`.  The data from `tripset` comes from a research project and has been fully anonymised.  Data such as that found in `tripset` can be generated, for instance, using GPS data collected from mobile phones.  In the present case, a preprocessing stage was performed so that trip-, link- and time-based data items (which we will describe shortly) could be generated from GPS data points, rendering the latter unnecessary.  We stress that `traveltimeHMM` does not perform this preprocessing stage, and that the software cannot make use of GPS data points directly.

```{r}
library(traveltimeHMM)
data(tripset)
head(tripset)
```

Travel data is organized around the notions of *trips* and *links*.  Links are road segments each with well-defined beginning and end points and which can be traversed.  A vehicle performs a trip when it travels from a start point to an end point through a sequence of links.  Thus trips can be considered as ordered sequences of links.  The data set includes data for a collection of trips.

- Field `tripID` contains each *trip*'s ID, whereas field `linkID` contains the IDs of each *link* making up a trip.  Both fields need to be numerical.  It is assumed that, in the data set, all trips are grouped together and all links of a given trip appear in the order in which they are traversed^[No verification is performed to that effect.].

- Field `timeBin` (character string) refers to the time "category" when the traversal of a given link occurred.  Time bins should reflect as much as possible time periods of the week encompassing similar traffic classes.  In `tripset` we find five time bins: `Weekday`, `MorningRush`, `EveningRush`, `EveningNight` and `Weekendday`.  Field `time` served as a basis for determining the time bin for each link traversal, as illustrated in table 1.  *### TO DO: include a mention regarding the need to provide the conversion algorithm from time stamps to time bins.  See issue #17.  ÉG 2019/07/08 ###* 

```{r echo = FALSE, results='asis'}
library(knitr)
library(kableExtra)
y <- c("Mon - Fri outside rush hour", "Mon - Fri, 7AM - 9AM", "Mon - Fri, 3PM - 6PM", "Sat 9AM - 9PM + Sun 9AM - 7PM", "Sat - Sun otherwise")
x <- c("Weekday", "MorningRush", "EveningRush", "Weekendday", "EveningNight")
z <- data.frame(cbind(y, x))
names(z) <- c("Period of the week", "Time bin")
knitr::kable(z, caption = "Table 1 - Example from `tripset` : Time bin by period of the week", escape = FALSE)
```

- Field `logspeed` contains the natural logarithm of the *speed* (in km/h) of traversal of each link.  This information is central to the estimation algorithm.

- Fields `traveltime` refers to the traversal time (in seconds) of each link.  This field is mostly for reference and is not used directly in the package.

- Fields `length` refers to the length (in meters) of each link.  This information is used by the prediction algorithm.

- Field `time` gives the start time in POSIXct format for the traversal of a given link.  Individual datums are not used directly; however, the start time of the very first traversal is likely to be useful for providing the start time of a whole trip to the prediction function.

## The statistical model

At the core of `traveltimeHMM` is a statistical model that aims at determining the probability distribution of *speeds* for each combination of *link* and *time bin*, on the basis of data just like that we just described.  We will first briefly present the model and its parameters.  We refer to Woodard et al. for an extensive description of the model.  We will subsequently present the four specific model types that are currently implemented.  Notably, some model types do not make use of all these parameters.

#### The model and its parameters

The most general model type of the four, the "trip-HMM" model, estimates the mean and standard deviation of the *speed probability distribution* for each combination of road link, time bin, and congestion state.  This latter concept involved defining a finite number of *hidden states* that reflect traffic fluidity in a given place at a given time, for instance the fact that one is driving downtown during rush hour (or not).  In our example, we chose to define two congestions states which we could implicitly call "not-congested" and "congested".

In order to deal properly with the fact that the congestion states are unobserved, the model needs to also estimate parameters that define the *probability* of a combination of road link and time bin *reaching a given state*.  These estimates are computed using a Markov model.  Finally, the model estimates a *trip effect* that captures variability in speed due to trip-specific conditions (e.g. driver habits).

Hence, the model parameters that are estimated are as follows.

* For each combination of road link $j$, time bin $b$ and congestion state $q$, we get:

    * The mean $\mu_{j,b,q}$ and standard deviation $\sigma_{j,b,q}$ of the speed probability distribution (on a logarithmic scale);
    
    * A vector $\gamma_{j,b}(q)$ which shows the probability of the congestion state $q$ for trips starting on link $j$ during $b$.

    * A transition matrix $\Gamma_{j,b}(\tilde{q},q)$ for the congestion state $q$ on $j$ and $b$, conditional on $\tilde{q}$, the congestion state in the previous link.
    
* We also get the trip effect $\log(E_i) \sim N(0,\tau^2)$ for each trip $i$, as well as its standard deviation $\tau$.

The other three model types are special cases of the most general model.  The "HMM" model type, which is the default type, makes abstraction of the trip effect: $\log(E_i)$ is restricted to $0$ whilst $\tau$ is set to $1$ # Shouldn't it be $\tau = 0$ in this case?  Otherwise $\log(E_i)$ will obviously depart from $0$.  ÉG 2019/07/22.  The "trip" model type instead considers the existence of a single congestion state; under this model the parameters $\gamma$ and $\Gamma$ remain undefined.  Finally, the "no-dependence" model type, which the most basic of the four, combines the restriction of the "HMM" and the "trip" model types and only takes into account parameters $\mu_{j,b,q}$ and $\sigma_{j,b,q}$ for the speed probability distribution.  Table 2 provides a summary of the characteristics of each model type.

```{r echo = FALSE, results='asis'}
library(knitr)
library(kableExtra)
x1 <- c("trip-HMM", "HMM (default)", "trip", "no-dependence")
x2 <- c("YES", "YES", "NO", "NO")
x3 <- c("YES", "NO", "YES", "NO")
z <- data.frame(cbind(x1, x2, x3))
names(z) <- c("Model type", "Hidden Markov model (`HMM`)", "Trip effect model (`trip`)")
knitr::kable(z, caption = "Table 2 - Model typology", escape = FALSE, align = 'lcc') %>%
  kable_styling(full_width = F) %>%
  column_spec(1, width = "2cm") %>%
  column_spec(2:3, width = "3cm")
```

## Model estimation

Model estimation is performed using Algorithm 1 from Woodard et al.  The estimation algorithm takes incoming data on speeds (on a logarithmic scale), trips, road links and time periods, and calculates a set of parameter estimates for the model.

Calculations are performed iteratively as is typical of non-linear optimization algorithms.  The estimates for each parameter are updated at each iteration, and the algorithm stops when either the variation in parameter estimates between two successive iterations is below a predefined threshold value, or a predefined maximum number of iterations is reached.

#### Calling `traveltimeHMM`

The estimation algorithm can be executed by calling the `traveltimeHMM` function.  The function's interface is as follows.

```{r eval=FALSE}
traveltimeHMM(logspeeds = NULL,
              trips = NULL,
              timeBins = NULL,
              linkIds = NULL,
              tripframe = NULL,
              nQ = 1L,
              model = c("HMM", "trip-HMM", "trip", "no-dependence"),
              tol.err = 10,
              L = 10L,
              max.it = 20,
              verbose = FALSE,
              max.speed = NULL,
              seed = NULL,
              tmat.p = NULL,
              init.p = NULL,
              debug = FALSE)
```

Function `traveltimeHMM` can be called either using *explicit parameters* or using a *composite object* incorporating the main parameters, as follows.  As an example of the first calling approach, we extract columns ```logspeeds```, ```trips```, ```timeBins``` and ```linkIds``` from the dataset and pass them explicitly:
```{r eval=FALSE}
# Example: calling traveltimeHMM with explicit parameters
fit <- traveltimeHMM(logspeeds = tripset$logspeed,
                     trips = tripset$tripID,
                     timeBins = tripset$timeBin,
                     linkIds = tripset$linkID,
                     nQ = 2,
                     max.it = 20)
```

As an example of the second calling approach, we construct and pass a single data frame object that contains those same four columns:
```{r eval=FALSE}
tripobject <- tripset[,c("logspeed", "tripID", "timeBin", "linkID")]
fit <- traveltimeHMM(tripframe = tripobject,
                     nQ = 2,
                     max.it = 20)
```

Table 3 provides a description for each parameter^[We have already examined the vectors that correspond to each of the first four parameters ```logspeeds```, ```trips```, ```timeBins``` and ```linkIds```, as well as the fifth parameter ```tripframe``` which incorporates these vectors.  We will not repeat the details here.].

```{r echo = FALSE, results='asis'}
library(knitr)
library(kableExtra)

r <-       c("`logspeeds`", "A numeric vector of speed observations (in km/h) on the (natural) log-scale.  Default is NULL.")

r <- rbind(r,
           c("`trips`", "An integer or character vector of trip ids for each observation of `speed`.  Default is NULL."))

r <- rbind(r,
           c("`timeBins`", "A character vector of time bins for each observation of `speed`.  Default is NULL."))

r <- rbind(r,
           c("`linkIds`", "A vector of link ids (route or way) for each observation of `speed`.  Default is NULL."))

r <- rbind(r,
           c("`tripframe`", "A data frame or equivalent object that contains one column for each of test.  Default is NULL.  Mutually exclusive with the full joint set of `logspeeds`, `trips`, `timeBins` and `linkIds`."))

r <- rbind(r,
           c("`nQ`", "An integer corresponding to the number of different congestion states that the traversal of a given link can take corresponding to $|\\{1, ..., Q\\}|$.    Models of the HMM family require $nQ \\geq 2$ whilst other models require exactly $nQ = 1$.  Default is $1$."))

r <- rbind(r,
           c("`model`", "Type of model as string.  Can take one of '`trip-HMM`', '`HMM`', '`trip`' or '`no-dependence`'.  Default is '`HMM`'.  See Table 3 for details."))

r <- rbind(r,
           c("`tol.err`", "A numeric variable representing the threshold under which the estimation algorithm will consider it has reached acceptable estimate values.  Default is $10$."))

r <- rbind(r,
           c("`L`", "An integer minimum number of observations per factor (`linkIds` x `timeBins`) to estimate the parameter for.  Default is $10$.  See explanation below."))

r <- rbind(r,
           c("`max.it`", "An integer for the upper limit of the iterations to be performed by the estimation algorithm.  Default is $20$."))

r <- rbind(r,
           c("`verbose`", "A boolean that triggers verbose output.  Default is `FALSE`."))

r <- rbind(r,
           c("`max.speed`", "An optional float for the maximum speed in km/h, on the linear scale (not the log-scale, unlike for `logspeeds`).  Default is `NULL` which in practice results in a maximum speed of 130 km/h.  # Change to default is 130.  ÉG 2019/07/22"))

r <- rbind(r,
           c("`seed`", "An optional float for the seed used for the random generation of the first Markov transition matrix and initial state vector.  Default is `NULL`. If not provided, then those objects are generated deterministically. The effect of `seed` is cancelled by tmat.p or init.p when provided."))

r <- rbind(r,
           c("`tmat.p`", "An optional Markov transition matrix $\\Gamma$ of size `nQ` \\times `nQ` with rows summing to $1$.  Default is `NULL`."))

r <- rbind(r,
           c("`init.p`", "An optional Markov initial state vector $\\gamma$ of size `nQ` with elements summing to $1$.  Default is `NULL`."))

r <- rbind(r,
           c("`debug`", "A boolean with value `TRUE` if we want debug information to be generated.  Default is `FALSE`."))

z <- as.data.frame(r[,2], row.names = r[,1])
names(z) <- ""
knitr::kable(z, caption = "Table 3 - Parameters for `traveltimeHMM`", escape = FALSE)
```

#### A word on imputation

The implementation allows imputing for combinations of road link and time bin for which the lack of sufficient observations prevents reliable parameter estimation.  When imputation is required for a given combination, estimates for $\mu$, $\sigma$, $\Gamma$ and $\gamma$ are calculated on the basis of data available for the time bin involved *for all road links*.  This approach differs from the one in Woodard et al., where imputation is performed on the basis of road classification data (e.g. "arterial" or "primary collector road").  This implementation does not handle road classification data.

Imputation is performed in the following three cases:

- Case 1: when a combination has fewer than $L$ *total observations*;

- Case 2: when a combination has fewer than $L$ *initial state observations only*;

- Case 3: when a combination has only initial states.

The number of observations specified in parameter `L` determines the threshold below which imputation occurs for cases 1 and 2.

#### Output from execution

Below is some typical output from executing `travetimeHMM`.  One can find:

* the maximum speed on the road network;
* the number of trips, road links and time bins;
* the number of iterations to be executed;
* an estimate of the total execution time, based on the time it takes for executing a firts iteration.

Error messages are described in the appendix.

```{r}
#> max.speed is not specified, setting at default value: 130 km/h
#> Model HMM with 4914 trips over 13235 roads and 5 time bins...
#> Expected completion of 20 iterations in 105 secs
#> Reached maximum number of iterations
```

#### Return values

The execution of `traveltimeHMM` returns a list of the parameters in Table 4. 

```{r echo = FALSE, results='asis'}
library(knitr)
library(kableExtra)

r <-       c("`factors`", "A factor of interactions (`linkIds` x `timeBins`) of length `nObs`.  Factors are in the format 'linkId.timeBin'.")

r <- rbind(r,
           c("`trip`", "A factor of trip IDs."))

r <- rbind(r,
           c("`tmat`", "A transition matrix with rows corresponding to `levels(factors)`, and with columns being the row-wise transition matrix of that factor. For example, `matrix(tmat[1,], ncol = nQ, nrow = nQ, byrow = TRUE)` is the transition matrix $\\hat{\\Gamma}$ of `levels(factors)[1]`.  NULL if hidden Markov modelling is not handled by the selected model type."))

r <- rbind(r,
           c("`init`", "An initial state probability matrix with rows corresponding to `levels(factors)`, and columns to the `nQ` states.  For example, `init[1,]` gives $\\hat{\\gamma}^\\top$ for `levels(factors)[1]`.  NULL if hidden Markov modelling is not handled by the selected model type."))

r <- rbind(r,
           c("`sd`", "A matrix of standard deviations estimates with rows corresponding to `levels(factors)`, and columns to standard deviation estimates $\\hat{\\sigma}$ for the `nQ` states."))

r <- rbind(r,
           c("`mean`", "A matrix of mean estimates with rows corresponding to `levels(factors)`, and columns to mean estimates $\\hat{\\sigma}$ for the `nQ` states."))

r <- rbind(r,
           c("`tau`", "A numeric variable for the standard deviation estimate $\\hat{\\tau}$ for the trip effect parameter `E`.  Equals $1$ if trip effect is not handled by the selected model type. # Should be changed to $0$, see earlier comment.  ÉG 2019/07/24."))

r <- rbind(r,
           c("`E`", "A numeric vector of trip effect estimates $\\hat{E}$ corresponding to `levels(trip)`.  Values are set to $0$ if trip effect is not handled by the selected model type."))

r <- rbind(r,
           c("`nQ`", "An integer corresponding to the number of different congestion states, equal to parameter `nQ` that was passed in the function call."))

r <- rbind(r,
           c("`nB`", "An integer corresponding to the number of unique time bins."))

r <- rbind(r,
           c("`nObs`", "An integer corresponding to the number of observations."))

r <- rbind(r,
           c("`model`", "Type of model as string.  Same as parameter `model` that was passed in the function call."))
z <- as.data.frame(r[,2], row.names = r[,1])
names(z) <- ""
knitr::kable(z, caption = "Table 4 - Components of the list object returned by `traveltimeHMM`", escape = FALSE)
```


## Prediction

Prediction is performed using Algorithm 2 from Woodard et al.  Each prediction is obtained by simulation on the basis of the parameter estimates supplied to the algorithm.  In short, the algorithm starts with the first road link and determines by simulation the initial congestion state considering the time bin and vector $\hat{\gamma}$.  The algorithm then samples the speed on the link given the congestion state and time bin as well as parameter estimates $\hat{\mu}$ and $\hat{\sigma}$.  Time after traversal of the link is then computed deterministically.  The process is repeated iteratively on the remaining links, this time using the information provided by $\hat{\Gamma}$, ultimately giving a point prediction for the travel time (in seconds) for the whole trip.

In our example, we obtained 1 000 independent predictions of the total travel speed on the selected trip, as shown in Figure 1.  The observed travel time for the same trip in the data set is 887.7327 seconds, whilst the mean of the 1 000 predictions for our simulation was 861.2652 seconds.

```{r echo = FALSE, results = 'asis', fig.cap = "Figure 1 - Histogram of prediction samples for a simulation run using the test data set"}
library(png)
img <- readPNG('histogram.png')
grid::grid.raster(img)
```


## References

Woodard, D., Nogin, G., Koch, P., Racz, D., Goldszmidt, M., Horvitz, E., 2017.  "Predicting travel time reliability using mobile phone GPS data".  *Transportation Research Part C*, 75, 30-44.  <http://dx.doi.org/10.1016/j.trc.2016.10.011>

## TO BE CONTINUED

## Old stock - the rest of the document can be deleted

Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
